///////////////////////////////////////////////////////////////////////////////////////
/// \file futtestgenerator.cpp
/// \brief The futhark test generator file
///
/// Used to generate futhark test files
/// production, respiration and evapotranspiration.
///
/// \author Ben Smith
/// $Date: 2019-10-09 19:37:07 +0200 (Wed, 09 Oct 2019) $
///
///////////////////////////////////////////////////////////////////////////////////////

// source: https://stackoverflow.com/questions/8412630/how-to-execute-a-piece-of-code-only-once
#include <atomic>
#define FIRST_TIME_HERE ([] { \
    static std::atomic<bool> first_time(true); \
    return first_time.exchange(false); } ())

#include <string>
#include <iostream>
#include <sstream>
#include <vector>
#include <fstream>
#include <string>
using namespace std;

// default to_string prints false as "0" etc.
std::string to_string(bool b) {
  return b ? "true" : "false";
}

static string real_string = "f64";

void gen_test_file(std::ostringstream& oss,
                   const string function){

  string test_dir = "futhark_tests/";
  ostringstream pathstream;
  pathstream << test_dir << function << "_test.fut";
  std::ofstream file(pathstream.str()); //open in constructor
  file << oss.str();
  cout << endl << "Printed testfile to: " << pathstream.str() << endl;
}

void dec_real(std::ostringstream& oss,
              const std::string& var,
              const double val
              ){
  oss << "  let " << var << " : " << real_string << " = " << val << endl;
}

void init_oss(std::ostringstream& oss){
  oss << "open import \"../../futsource/everything\"" << endl;
  oss << endl;
  oss << "let input =" << endl;
}


void inplace_update(std::ostringstream& oss,
                    const std::string& object,
                    const std::string& field,
                    const std::string& value
                    ) {
  oss << "  let " << object << " = " << object << " with " << field << " = " << value << endl;
  }


void init_obj(std::ostringstream& oss,
              const std::string& object,
              const std::string& object_gen
              ) {
  oss << "  let " << object << " = " << object_gen << "()" << endl;
  }

void obj_with_fields(std::ostringstream& oss,
                    const std::string& object,
                    const std::string& object_gen,
                    const string fields_values[],
                    const unsigned int num_fields
                    ) {
  init_obj(oss, object, object_gen);
  for (unsigned int i = 0; i < (num_fields*2); i+=2){
    inplace_update(oss, object, fields_values[i], fields_values[i+1]);
  }
  oss << endl;
}

void finish_input(std::ostringstream& oss,
                  const string input){
  oss << "  in " << input << endl;
  oss << endl;
}

void gen_entry_point_test(std::ostringstream& oss
                         ,const string function
                         ,const string field
                         ,const string value
                         ) {
  // print test comment
  oss << "-- Autogenerated test of " << function << " output " << field << endl;
  oss << "-- ==" << endl;
  oss << "-- entry: " << field << "_test" << endl;
  oss << "-- input {}" << endl;
  oss << "-- output { " << value << " }" << endl;
  oss << endl;

  // print entrypoint
  oss << "entry " << field << "_test" << " =" << endl;
  oss << "  (" << function << " input)." << field << endl;
  oss << endl;
 }

void gen_entry_point_tests(std::ostringstream& oss
                          ,const string function
                          ,const string fields_values[]
                          ,const unsigned int num_fields
                        )
  {
    for (unsigned int i = 0; i < (num_fields*2); i+=2){
      gen_entry_point_test(oss, function, fields_values[i], fields_values[i+1]);
    }
  }
